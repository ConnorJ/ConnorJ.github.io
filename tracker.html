<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag Racing Speed Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
            padding: 10px;
            user-select: none;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ff6b35;
        }

        .unit-toggle {
            background: #333;
            border: 2px solid #ff6b35;
            color: #fff;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            min-height: 44px;
            margin-bottom: 10px;
        }

        .unit-toggle:active {
            background: #ff6b35;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 12px;
        }

        .status-item {
            background: #333;
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid #555;
        }

        .status-active {
            border-color: #00ff00;
            background: #003300;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            padding: 15px;
            background: #333;
            border: 2px solid #ff6b35;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            min-height: 44px;
            min-width: 100px;
        }

        .btn:active {
            background: #ff6b35;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #ff6b35;
            border-color: #ff6b35;
        }

        .btn-success {
            background: #28a745;
            border-color: #28a745;
        }

        .btn-danger {
            background: #dc3545;
            border-color: #dc3545;
        }

        .chart-container {
            background: #111;
            border: 2px solid #333;
            border-radius: 8px;
            margin-bottom: 20px;
            height: 300px;
            position: relative;
        }

        #chart {
            width: 100%;
            height: 100%;
            border-radius: 6px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: #222;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .metric-card.achieved {
            border-color: #00ff00;
            background: #003300;
        }

        .metric-label {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
        }

        .metric-target {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }

        .calibration-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #222;
            border: 2px solid #ff6b35;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 300px;
        }

        .calibration-progress {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #ff6b35;
            width: 0%;
            transition: width 0.1s ease;
        }

        .warning {
            background: #ff6b35;
            color: #000;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        @media (orientation: landscape) {
            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
            
            .chart-container {
                height: 200px;
            }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 20px;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">Drag Racing Speed Tracker</div>
        <button id="unitToggle" class="unit-toggle">Switch to Kilometers</button>
    </div>

    <div id="permissionWarning" class="warning">
        <button id="grantSensors" class="btn btn-primary">Grant Sensor Access</button>
    </div>

    <div id="browserWarning" class="warning hidden"></div>

    <div class="status-bar">
        <div id="sensorStatus" class="status-item">Sensor: Disconnected</div>
        <div id="samplingRate" class="status-item">Rate: 0 Hz</div>
        <div id="currentSpeed" class="status-item">Speed: 0 mph</div>
        <div id="calibrationStatus" class="status-item">Calibration: Needed</div>
        <div id="runStatus" class="status-item">Status: Standby</div>
    </div>

    <div class="controls">
        <button id="calibrateBtn" class="btn">Calibrate</button>
        <button id="startBtn" class="btn btn-success">Start Run</button>
        <button id="stopBtn" class="btn btn-danger" disabled>Stop Run</button>
        <button id="resetBtn" class="btn">Reset</button>
    </div>

    <div class="chart-container">
        <canvas id="chart"></canvas>
    </div>

    <div class="metrics-grid" id="metricsGrid">
        <!-- Metrics will be populated by JavaScript -->
    </div>

    <div id="calibrationModal" class="calibration-modal hidden">
        <div class="modal-content">
            <h3>Sensor Calibration</h3>
            <p>Hold device steady for calibration</p>
            <div class="calibration-progress">
                <div id="calibrationProgress" class="progress-bar"></div>
            </div>
            <p id="calibrationText">Keep device still...</p>
        </div>
    </div>

    <script>
        class DragRacingTracker {
            constructor() {
                this.isMetric = false;
                this.isCalibrated = false;
                this.isRunning = false;
                this.hasPermission = false;
                this.sensorData = [];
                this.metrics = {};
                this.runStartTime = null;
                this.calibrationOffset = { x: 0, y: 0, z: 0 };
                this.lastTimestamp = 0;
                this.velocity = 0;
                this.distance = 0;
                this.position = 0;
                this.chartData = [];
                this.samplingRate = 0;
                this.lastSampleTime = 0;
                this.sampleCount = 0;
                
                // Enhanced filtering and processing
                this.accelerationBuffer = [];
                this.velocityBuffer = [];
                this.motionThreshold = 0.5; // m/s² threshold for motion detection
                this.noiseThreshold = 2.0; // m/s² threshold for noise rejection
                this.isMoving = false;
                this.stationaryTime = 0;
                this.lastValidAcceleration = 0;
                
                this.initMetrics();
                this.initUI();
                this.detectBrowser();
                this.requestPermissions();
            }

            initMetrics() {
                this.metricDefinitions = {
                    speed: [
                        { id: '0-40kph', label: '0-40 km/h', target: null, achieved: false, value: null },
                        { id: '0-60kph', label: '0-60 km/h', target: null, achieved: false, value: null },
                        { id: '0-80kph', label: '0-80 km/h', target: null, achieved: false, value: null },
                        { id: '0-100kph', label: '0-100 km/h', target: null, achieved: false, value: null },
                        { id: '0-120kph', label: '0-120 km/h', target: null, achieved: false, value: null, conditional: true },
                        { id: '0-200kph', label: '0-200 km/h', target: null, achieved: false, value: null, conditional: true },
                        { id: '0-30mph', label: '0-30 mph', target: null, achieved: false, value: null },
                        { id: '0-60mph', label: '0-60 mph', target: null, achieved: false, value: null },
                        { id: '60-100mph', label: '60-100 mph', target: null, achieved: false, value: null, conditional: true },
                        { id: '0-100mph', label: '0-100 mph', target: null, achieved: false, value: null, conditional: true },
                        { id: '0-150mph', label: '0-150 mph', target: null, achieved: false, value: null, conditional: true }
                    ],
                    distance: [
                        { id: '1000m', label: '1000m', target: null, achieved: false, value: null },
                        { id: '1/8mile', label: '1/8 mile', target: null, achieved: false, value: null },
                        { id: '1/4mile', label: '1/4 mile', target: null, achieved: false, value: null },
                        { id: '1mile', label: '1 mile', target: null, achieved: false, value: null, conditional: true }
                    ]
                };
            }

            initUI() {
                this.elements = {
                    unitToggle: document.getElementById('unitToggle'),
                    grantSensors: document.getElementById('grantSensors'),
                    permissionWarning: document.getElementById('permissionWarning'),
                    browserWarning: document.getElementById('browserWarning'),
                    sensorStatus: document.getElementById('sensorStatus'),
                    samplingRate: document.getElementById('samplingRate'),
                    currentSpeed: document.getElementById('currentSpeed'),
                    calibrationStatus: document.getElementById('calibrationStatus'),
                    runStatus: document.getElementById('runStatus'),
                    calibrateBtn: document.getElementById('calibrateBtn'),
                    startBtn: document.getElementById('startBtn'),
                    stopBtn: document.getElementById('stopBtn'),
                    resetBtn: document.getElementById('resetBtn'),
                    chart: document.getElementById('chart'),
                    metricsGrid: document.getElementById('metricsGrid'),
                    calibrationModal: document.getElementById('calibrationModal'),
                    calibrationProgress: document.getElementById('calibrationProgress'),
                    calibrationText: document.getElementById('calibrationText')
                };

                this.initEventListeners();
                this.initChart();
                this.renderMetrics();
            }

            initEventListeners() {
                this.elements.unitToggle.addEventListener('click', () => this.toggleUnits());
                this.elements.grantSensors.addEventListener('click', () => this.requestPermissions());
                this.elements.calibrateBtn.addEventListener('click', () => this.startCalibration());
                this.elements.startBtn.addEventListener('click', () => this.startRun());
                this.elements.stopBtn.addEventListener('click', () => this.stopRun());
                this.elements.resetBtn.addEventListener('click', () => this.resetAll());

                // Keep screen awake during runs
                document.addEventListener('visibilitychange', () => {
                    if (this.isRunning && document.hidden) {
                        navigator.wakeLock?.request('screen');
                    }
                });
            }

            detectBrowser() {
                const userAgent = navigator.userAgent;
                let warning = '';

                if (userAgent.includes('Firefox')) {
                    warning = 'Firefox may have reduced sensor accuracy';
                } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                    warning = 'Older Safari versions may have lower sampling rates';
                }

                if (warning) {
                    this.elements.browserWarning.textContent = warning;
                    this.elements.browserWarning.classList.remove('hidden');
                }
            }

            async requestPermissions() {
                try {
                    if ('DeviceMotionEvent' in window) {
                        if (typeof DeviceMotionEvent.requestPermission === 'function') {
                            const permission = await DeviceMotionEvent.requestPermission();
                            if (permission === 'granted') {
                                this.hasPermission = true;
                                this.elements.permissionWarning.classList.add('hidden');
                                this.initSensors();
                            }
                        } else {
                            this.hasPermission = true;
                            this.elements.permissionWarning.classList.add('hidden');
                            this.initSensors();
                        }
                    }
                } catch (error) {
                    console.error('Permission request failed:', error);
                }
            }

            initSensors() {
                if ('LinearAccelerationSensor' in window) {
                    try {
                        this.sensor = new LinearAccelerationSensor({ frequency: 100 });
                        this.sensor.addEventListener('reading', () => this.handleSensorReading());
                        this.sensor.addEventListener('error', () => this.fallbackToDeviceMotion());
                        this.sensor.start();
                        this.elements.sensorStatus.textContent = 'Sensor: LinearAcceleration';
                        this.elements.sensorStatus.classList.add('status-active');
                    } catch (error) {
                        this.fallbackToDeviceMotion();
                    }
                } else {
                    this.fallbackToDeviceMotion();
                }
            }

            fallbackToDeviceMotion() {
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (event) => this.handleDeviceMotion(event));
                    this.elements.sensorStatus.textContent = 'Sensor: DeviceMotion';
                    this.elements.sensorStatus.classList.add('status-active');
                } else {
                    this.elements.sensorStatus.textContent = 'Sensor: Not Available';
                }
            }

            handleSensorReading() {
                if (this.sensor) {
                    this.processSensorData({
                        x: this.sensor.x,
                        y: this.sensor.y,
                        z: this.sensor.z,
                        timestamp: performance.now()
                    });
                }
            }

            handleDeviceMotion(event) {
                if (event.accelerationIncludingGravity) {
                    this.processSensorData({
                        x: event.accelerationIncludingGravity.x,
                        y: event.accelerationIncludingGravity.y,
                        z: event.accelerationIncludingGravity.z - 9.81, // Remove gravity
                        timestamp: performance.now()
                    });
                }
            }

            processSensorData(data) {
                // Calculate sampling rate
                if (this.lastSampleTime) {
                    this.sampleCount++;
                    if (this.sampleCount % 10 === 0) {
                        const rate = 1000 / ((data.timestamp - this.lastSampleTime) / 10);
                        this.samplingRate = Math.round(rate);
                        this.elements.samplingRate.textContent = `Rate: ${this.samplingRate} Hz`;
                    }
                }
                this.lastSampleTime = data.timestamp;

                // Apply calibration offset
                const calibratedData = {
                    x: data.x - this.calibrationOffset.x,
                    y: data.y - this.calibrationOffset.y,
                    z: data.z - this.calibrationOffset.z,
                    timestamp: data.timestamp
                };

                // Enhanced processing with filtering
                const processedData = this.applyFiltering(calibratedData);
                
                this.sensorData.push(processedData);

                if (this.isRunning) {
                    this.updateMetrics(processedData);
                    this.updateChart();
                }

                // Keep only last 1000 samples to manage memory
                if (this.sensorData.length > 1000) {
                    this.sensorData.shift();
                }
            }

            applyFiltering(data) {
                // Calculate acceleration magnitude
                const magnitude = Math.sqrt(data.x ** 2 + data.y ** 2 + data.z ** 2);
                
                // Add to acceleration buffer for filtering
                this.accelerationBuffer.push({
                    magnitude: magnitude,
                    timestamp: data.timestamp,
                    raw: { x: data.x, y: data.y, z: data.z }
                });

                // Keep buffer size manageable (last 20 samples for ~200ms at 100Hz)
                if (this.accelerationBuffer.length > 20) {
                    this.accelerationBuffer.shift();
                }

                // Apply noise rejection - discard extreme outliers
                if (magnitude > this.noiseThreshold * 5) {
                    // Use last valid acceleration if current reading is extreme noise
                    return {
                        ...data,
                        filteredMagnitude: this.lastValidAcceleration
                    };
                }

                // Apply moving average filter (middle 90% of recent samples)
                let filteredMagnitude = magnitude;
                if (this.accelerationBuffer.length >= 5) {
                    const recentMagnitudes = this.accelerationBuffer
                        .slice(-10)
                        .map(d => d.magnitude)
                        .sort((a, b) => a - b);
                    
                    // Remove top and bottom 5% (outlier rejection)
                    const trimCount = Math.floor(recentMagnitudes.length * 0.05);
                    const trimmedData = recentMagnitudes.slice(trimCount, -trimCount || undefined);
                    
                    // Calculate moving average of remaining data
                    filteredMagnitude = trimmedData.reduce((sum, val) => sum + val, 0) / trimmedData.length;
                }

                // Motion detection with hysteresis
                if (!this.isMoving && filteredMagnitude > this.motionThreshold) {
                    this.isMoving = true;
                    this.stationaryTime = 0;
                } else if (this.isMoving && filteredMagnitude < this.motionThreshold * 0.5) {
                    this.stationaryTime += 1;
                    // Require 1 second of low acceleration to consider stopped
                    if (this.stationaryTime > 100) { // ~1 sec at 100Hz
                        this.isMoving = false;
                        // Zero velocity update when stopped
                        if (this.isRunning) {
                            this.velocity *= 0.95; // Gradual velocity decay
                        }
                    }
                }

                this.lastValidAcceleration = filteredMagnitude;

                return {
                    ...data,
                    filteredMagnitude: filteredMagnitude,
                    isMoving: this.isMoving
                };
            }

            async startCalibration() {
                // Stop any running session before calibrating
                if (this.isRunning) {
                    this.stopRun();
                }
                
                this.elements.calibrationModal.classList.remove('hidden');
                this.elements.calibrationText.textContent = 'Keep device still...';
                
                const calibrationData = [];
                const calibrationTime = 3000; // 3 seconds
                const startTime = performance.now();

                const calibrationInterval = setInterval(() => {
                    const elapsed = performance.now() - startTime;
                    const progress = (elapsed / calibrationTime) * 100;
                    this.elements.calibrationProgress.style.width = `${Math.min(progress, 100)}%`;

                    if (this.sensorData.length > 0) {
                        calibrationData.push({...this.sensorData[this.sensorData.length - 1]});
                    }

                    if (elapsed >= calibrationTime) {
                        clearInterval(calibrationInterval);
                        this.finishCalibration(calibrationData);
                    }
                }, 50);
            }

            finishCalibration(calibrationData) {
                if (calibrationData.length > 10) {
                    // Remove outliers for better calibration
                    const xValues = calibrationData.map(d => d.x).sort((a, b) => a - b);
                    const yValues = calibrationData.map(d => d.y).sort((a, b) => a - b);
                    const zValues = calibrationData.map(d => d.z).sort((a, b) => a - b);
                    
                    // Use median values to avoid outlier influence
                    const medianIndex = Math.floor(calibrationData.length / 2);
                    this.calibrationOffset = {
                        x: xValues[medianIndex],
                        y: yValues[medianIndex],
                        z: zValues[medianIndex]
                    };
                    
                    // Reset processing buffers
                    this.accelerationBuffer = [];
                    this.velocityBuffer = [];
                    this.velocity = 0;
                    this.distance = 0;
                    this.isMoving = false;
                    this.stationaryTime = 0;
                    
                    this.isCalibrated = true;
                    this.elements.calibrationStatus.textContent = 'Calibration: Complete';
                    this.elements.calibrationStatus.classList.add('status-active');
                } else {
                    this.elements.calibrationStatus.textContent = 'Calibration: Failed';
                }

                this.elements.calibrationModal.classList.add('hidden');
                this.elements.calibrationProgress.style.width = '0%';
            }

            async startRun() {
                if (!this.isCalibrated) {
                    await this.startCalibration();
                    // Wait for calibration to complete
                    return new Promise((resolve) => {
                        const checkCalibration = () => {
                            if (this.isCalibrated) {
                                this.beginRun();
                                resolve();
                            } else {
                                setTimeout(checkCalibration, 100);
                            }
                        };
                        checkCalibration();
                    });
                } else {
                    this.beginRun();
                }
            }

            beginRun() {
                this.isRunning = true;
                this.runStartTime = performance.now();
                this.velocity = 0;
                this.distance = 0;
                this.chartData = [];
                this.resetMetrics();

                this.elements.startBtn.disabled = true;
                this.elements.stopBtn.disabled = false;
                this.elements.runStatus.textContent = 'Status: Recording';
                this.elements.runStatus.classList.add('status-active');

                // Request wake lock
                if ('wakeLock' in navigator) {
                    navigator.wakeLock.request('screen');
                }
            }

            stopRun() {
                this.isRunning = false;
                this.elements.startBtn.disabled = false;
                this.elements.stopBtn.disabled = true;
                this.elements.runStatus.textContent = 'Status: Complete';
                this.elements.runStatus.classList.remove('status-active');

                this.saveRun();
            }

            updateMetrics(sensorData) {
                if (!this.runStartTime) return;

                const timeElapsed = (sensorData.timestamp - this.runStartTime) / 1000;
                const dt = timeElapsed - this.lastTimestamp;
                
                if (dt <= 0) return;

                // Use filtered acceleration magnitude
                const acceleration = sensorData.filteredMagnitude || 0;
                
                // Only update velocity if we're actually moving
                if (sensorData.isMoving && acceleration > this.motionThreshold) {
                    // Apply improved integration with drift correction
                    const velocityChange = acceleration * dt;
                    this.velocity += velocityChange;
                    
                    // Add to velocity buffer for smoothing
                    this.velocityBuffer.push(this.velocity);
                    if (this.velocityBuffer.length > 10) {
                        this.velocityBuffer.shift();
                    }
                    
                    // Apply velocity smoothing (moving average)
                    if (this.velocityBuffer.length >= 3) {
                        const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b);
                        // Use median of recent velocities to reduce noise
                        const medianIndex = Math.floor(sortedVelocities.length / 2);
                        this.velocity = sortedVelocities[medianIndex];
                    }
                } else if (!sensorData.isMoving) {
                    // Gradual velocity decay when not moving
                    this.velocity *= 0.9;
                    if (Math.abs(this.velocity) < 0.1) {
                        this.velocity = 0; // Zero out very small velocities
                    }
                }

                // Ensure velocity is never negative (for drag racing)
                this.velocity = Math.max(0, this.velocity);
                
                // Update distance (m) - only when moving
                if (this.velocity > 0) {
                    this.distance += this.velocity * dt;
                }

                // Convert to display units
                const speedKph = this.velocity * 3.6;
                const speedMph = speedKph * 0.621371;
                const distanceM = this.distance;
                const distanceFt = distanceM * 3.28084;

                // Add data to chart
                const currentSpeed = this.isMetric ? speedKph : speedMph;
                this.chartData.push({ 
                    time: timeElapsed, 
                    speed: currentSpeed, 
                    acceleration: acceleration,
                    isMoving: sensorData.isMoving 
                });
                
                // Keep only last 30 seconds of data
                this.chartData = this.chartData.filter(d => d.time > timeElapsed - 30);

                // Update current speed display
                const speedUnit = this.isMetric ? 'km/h' : 'mph';
                this.elements.currentSpeed.textContent = `Speed: ${currentSpeed.toFixed(1)} ${speedUnit}`;

                // Check speed metrics
                this.checkSpeedMetric('0-40kph', speedKph, 40);
                this.checkSpeedMetric('0-60kph', speedKph, 60);
                this.checkSpeedMetric('0-80kph', speedKph, 80);
                this.checkSpeedMetric('0-100kph', speedKph, 100);
                this.checkSpeedMetric('0-120kph', speedKph, 120);
                this.checkSpeedMetric('0-200kph', speedKph, 200);
                this.checkSpeedMetric('0-30mph', speedMph, 30);
                this.checkSpeedMetric('0-60mph', speedMph, 60);
                this.checkSpeedMetric('60-100mph', speedMph, 100, 60);
                this.checkSpeedMetric('0-100mph', speedMph, 100);
                this.checkSpeedMetric('0-150mph', speedMph, 150);

                // Check distance metrics
                this.checkDistanceMetric('1000m', distanceM, 1000, timeElapsed);
                this.checkDistanceMetric('1/8mile', distanceM, 201.168, timeElapsed); // 1/8 mile in meters
                this.checkDistanceMetric('1/4mile', distanceM, 402.336, timeElapsed); // 1/4 mile in meters
                this.checkDistanceMetric('1mile', distanceM, 1609.344, timeElapsed); // 1 mile in meters

                this.lastTimestamp = timeElapsed;
                this.renderMetrics();
            }

            checkSpeedMetric(id, currentSpeed, targetSpeed, fromSpeed = 0) {
                const metric = this.metricDefinitions.speed.find(m => m.id === id);
                if (metric && !metric.achieved && currentSpeed >= targetSpeed) {
                    const timeElapsed = (performance.now() - this.runStartTime) / 1000;
                    metric.achieved = true;
                    metric.value = `${timeElapsed.toFixed(2)}s`;
                    
                    // Audio feedback
                    this.playTone(800, 200);
                }
            }

            checkDistanceMetric(id, currentDistance, targetDistance, timeElapsed) {
                const metric = this.metricDefinitions.distance.find(m => m.id === id);
                if (metric && !metric.achieved && currentDistance >= targetDistance) {
                    metric.achieved = true;
                    const speed = this.isMetric ? this.velocity * 3.6 : this.velocity * 2.237;
                    const unit = this.isMetric ? 'km/h' : 'mph';
                    metric.value = `${timeElapsed.toFixed(2)}s @ ${speed.toFixed(1)}${unit}`;
                    
                    // Audio feedback
                    this.playTone(1000, 300);
                }
            }

            playTone(frequency, duration) {
                if ('AudioContext' in window || 'webkitAudioContext' in window) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration / 1000);
                }
            }

            toggleUnits() {
                this.isMetric = !this.isMetric;
                this.elements.unitToggle.textContent = this.isMetric ? 'Switch to Miles' : 'Switch to Kilometers';
                
                // Update current speed display with new units
                const speedUnit = this.isMetric ? 'km/h' : 'mph';
                const currentSpeedValue = this.isRunning ? 
                    (this.isMetric ? this.velocity * 3.6 : this.velocity * 2.237) : 0;
                this.elements.currentSpeed.textContent = `Speed: ${currentSpeedValue.toFixed(1)} ${speedUnit}`;
                
                this.renderMetrics();
            }

            renderMetrics() {
                const visibleMetrics = [...this.metricDefinitions.speed, ...this.metricDefinitions.distance]
                    .filter(metric => {
                        if (metric.conditional && !metric.achieved) {
                            // Only show conditional metrics if achieved or close to achievement
                            return false;
                        }
                        
                        // Filter by unit system
                        if (this.isMetric) {
                            return !metric.label.includes('mph') && !metric.label.includes('mile');
                        } else {
                            return !metric.label.includes('km/h') && !metric.label.includes('1000m');
                        }
                    });

                this.elements.metricsGrid.innerHTML = visibleMetrics.map(metric => `
                    <div class="metric-card ${metric.achieved ? 'achieved' : ''}">
                        <div class="metric-label">${metric.label}</div>
                        <div class="metric-value">${metric.value || '---'}</div>
                        ${metric.target ? `<div class="metric-target">Target: ${metric.target}</div>` : ''}
                    </div>
                `).join('');
            }

            resetMetrics() {
                this.metricDefinitions.speed.forEach(metric => {
                    metric.achieved = false;
                    metric.value = null;
                });
                this.metricDefinitions.distance.forEach(metric => {
                    metric.achieved = false;
                    metric.value = null;
                });
                this.renderMetrics();
            }

            resetAll() {
                this.stopRun();
                this.resetMetrics();
                this.velocity = 0;
                this.distance = 0;
                this.chartData = [];
                
                // Reset filtering variables
                this.accelerationBuffer = [];
                this.velocityBuffer = [];
                this.isMoving = false;
                this.stationaryTime = 0;
                this.lastValidAcceleration = 0;
                
                this.updateChart();
                
                // Reset current speed display
                const speedUnit = this.isMetric ? 'km/h' : 'mph';
                this.elements.currentSpeed.textContent = `Speed: 0.0 ${speedUnit}`;
            }

            initChart() {
                this.ctx = this.elements.chart.getContext('2d');
                // Delay resize to ensure element is rendered
                setTimeout(() => {
                    this.resizeChart();
                }, 100);
                window.addEventListener('resize', () => this.resizeChart());
            }

            resizeChart() {
                const rect = this.elements.chart.parentElement.getBoundingClientRect();
                this.elements.chart.width = rect.width - 4; // Account for border
                this.elements.chart.height = rect.height - 4; // Account for border
                this.updateChart(); // Redraw chart after resize
            }

            updateChart() {
                if (!this.ctx) return;

                const canvas = this.elements.chart;
                const ctx = this.ctx;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= 10; i++) {
                    const x = (canvas.width / 10) * i;
                    const y = (canvas.height / 10) * i;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                if (this.chartData.length < 2) return;

                // Find max speed for scaling
                const maxSpeed = Math.max(...this.chartData.map(d => d.speed), 50); // Minimum scale of 50
                const minTime = Math.min(...this.chartData.map(d => d.time));
                const maxTime = Math.max(...this.chartData.map(d => d.time));
                const timeRange = Math.max(maxTime - minTime, 1); // Minimum range of 1 second

                // Draw speed line
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                this.chartData.forEach((point, index) => {
                    const x = ((point.time - minTime) / timeRange) * canvas.width;
                    const y = canvas.height - (point.speed / maxSpeed) * canvas.height;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();

                // Draw labels
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.fillText(`Max: ${maxSpeed.toFixed(1)} ${this.isMetric ? 'km/h' : 'mph'}`, 10, 20);
                ctx.fillText(`Time: ${timeRange.toFixed(1)}s`, 10, canvas.height - 10);
            }

            saveRun() {
                const runs = JSON.parse(localStorage.getItem('dragRacingRuns') || '[]');
                const runData = {
                    timestamp: new Date().toISOString(),
                    metrics: JSON.parse(JSON.stringify(this.metricDefinitions)),
                    chartData: [...this.chartData]
                };
                
                runs.unshift(runData);
                if (runs.length > 10) runs.pop(); // Keep only last 10 runs
                
                localStorage.setItem('dragRacingRuns', JSON.stringify(runs));
            }
        }

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const tracker = new DragRacingTracker();
        });
    </script>
</body>
</html>
    